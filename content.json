{"meta":{"title":"Ocean's Blog","subtitle":"有朝一日刀在手，斩遍天下恩爱狗！","description":"真正的秋名山车神","author":"冷亚麻色的？","url":"http://OceanMiki.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-01-21T03:20:09.000Z","updated":"2020-01-21T03:22:11.605Z","comments":false,"path":"tags/index.html","permalink":"http://oceanmiki.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-21T03:22:48.000Z","updated":"2020-01-21T03:23:47.933Z","comments":false,"path":"categories/index.html","permalink":"http://oceanmiki.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iTerm2终端配置","slug":"iTerm2终端配置","date":"2023-12-07T01:31:08.434Z","updated":"2023-12-07T02:41:26.029Z","comments":true,"path":"2023/12/07/iTerm2终端配置/","link":"","permalink":"http://oceanmiki.github.io/2023/12/07/iTerm2%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/","excerpt":"美化终端，简化操作","text":"美化终端，简化操作 右键打开iTerm出现两个窗口解决方案通过设置iTerm的偏好设置即可解决此问题 打开iTerm，点击 Preference 在General &gt; Startup 中将 Window restoration policy 修改为【Only Restore Hotkey Window】 image-20231207103633065","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://oceanmiki.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://oceanmiki.github.io/tags/Mac/"}]},{"title":"Mac升级12.6版本后给手机开热点","slug":"Mac升级12.6版本后给手机开热点","date":"2022-12-12T03:29:55.956Z","updated":"2023-12-07T02:49:04.359Z","comments":true,"path":"2022/12/12/Mac升级12.6版本后给手机开热点/","link":"","permalink":"http://oceanmiki.github.io/2022/12/12/Mac%E5%8D%87%E7%BA%A712.6%E7%89%88%E6%9C%AC%E5%90%8E%E7%BB%99%E6%89%8B%E6%9C%BA%E5%BC%80%E7%83%AD%E7%82%B9/","excerpt":"升级系统后WiFi热点搜不到了","text":"升级系统后WiFi热点搜不到了 解决方法Macbook12.6版本无法给手机开热点解决方案 我是电脑网线连接的网线，然后通过共享给手机开的热点，但自从升级了mac系统就用不了了 打开电脑设置，点击“共享” 共享中点击互联网共享设置成下图 点开“网络”，在上方“位置”处点击“自动”编辑位置 点击加号，随便取一个名字，点击完成 退出设置，在手机上搜索电脑的热点名称，就可以连接啦 电脑热点的名称在“互联网共享”的“wi-fi选项”中","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://oceanmiki.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://oceanmiki.github.io/tags/Mac/"}]},{"title":"百度实习总结","slug":"百度实习总结","date":"2022-06-23T06:53:09.666Z","updated":"2022-06-23T08:01:16.851Z","comments":true,"path":"2022/06/23/百度实习总结/","link":"","permalink":"http://oceanmiki.github.io/2022/06/23/%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"岁月如梭，实习结束已过去大半年之久，好不容易忙完学校毕业的事情，才闲下心来记录实习的经历","text":"岁月如梭，实习结束已过去大半年之久，好不容易忙完学校毕业的事情，才闲下心来记录实习的经历 认识新朋友2021.7.7是报到的第一天，我跟着行政人员转来转去，终于看到了在工位等我的向蔚姐姐和蛋总（姐姐），我把背包放在临时工位之后就跟着两个姐姐一起去食堂吃午饭。到了晚上，我、向蔚姐姐、刘艺姐姐、时安然姐姐以及黄琴姐姐一起去吃饭，这也是之后固定的饭友团了。我在实习期间一直被带着吃饭，也就有了每天的固定对话 “吃饭” “走”（还有英文版“fan” “go”）有时候在食堂吃，有时候去外面吃（一般是麻辣烫和米线二选一） 实习了俩星期后，我坐的临时工位旁边又迎来了一位新同事，侯庭飞。 有趣的团建短短小半年时间，我参加了两次团建，第一次是部门的团建，去的北京香山公园，第二次是团队的团建，去的是环球影城。 香山公园环球影城日常的工作每天到工位先看两篇扇贝阅读醒醒脑子（后来起不来那么早，就荒废了）。之后，刷LeetCode每日一题，如果是easy就再加一道，如果是没做过的mid就看题解，如果是hard就摆烂。然后去休息区泡一杯花茶，打开电脑上内网浏览最近公司的新闻，在寻Ta专区中看看又有哪些“交友”的帅哥美女，顺便逛逛二手交易区的新上架商品。等到11:30去吃饭，吃完饭后绕着公司转几圈，12:30返回工位玩会手机，戴上耳塞睡觉睡到14:00。睡醒后带薪上洗手间（后来我发现这个点特别多人，所以我就提前5分钟去），上完洗手间后，开始学习，正所谓笨鸟先飞，阅读《鸟哥的linux私房菜》、《图解HTTP》等电子书，中途找个机会去休息区洗下午发的水果吃，顺便聊会天。等到17:30吃晚饭，吃完饭绕着公司转几圈，18:30回到工位玩会手机。19:00思考今天的日报怎么写，写完之后定时21:30发送。最后打开知乎指点江山，激扬文字。21:00准时预约打车回学校。","categories":[{"name":"工作","slug":"工作","permalink":"http://oceanmiki.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://oceanmiki.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"picture","slug":"picture","date":"2021-06-30T12:40:28.000Z","updated":"2021-06-30T13:54:24.402Z","comments":true,"path":"2021/06/30/picture/","link":"","permalink":"http://oceanmiki.github.io/2021/06/30/picture/","excerpt":"上传了一张图片","text":"上传了一张图片 这是一个标题 这是一张图片 注意事项 图片直接拖进typora，会自动保存在/source/images/blog_name下 记得在typora中格式—&gt;图像—&gt;设置图片根目录为source","categories":[{"name":"deploy","slug":"deploy","permalink":"http://oceanmiki.github.io/categories/deploy/"}],"tags":[{"name":"test","slug":"test","permalink":"http://oceanmiki.github.io/tags/test/"}]},{"title":"暑期实习面经汇总","slug":"暑期实习面经汇总","date":"2021-06-12T14:26:56.379Z","updated":"2021-06-20T14:23:43.590Z","comments":true,"path":"2021/06/12/暑期实习面经汇总/","link":"","permalink":"http://oceanmiki.github.io/2021/06/12/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/","excerpt":"记录一下咸鱼的找实习经历","text":"记录一下咸鱼的找实习经历 美团后端（一面挂） 笔试5道a了两道，第三道80%case，5.12一面 网络 post与get的区别？ http和https的区别？ http的三次握手？ cookie和session的区别？它们会过期吗？如果故意修改cookie有什么影响？怎么防止这种问题的出现？ 数据库 除了课程设计你有用过数据库里面的索引吗？ 为什么要用索引？索引是怎么提升查询效率的？ hash索引和b+树索引的区别？ b数和b+树的区别？b+树为什么就比b树存储的信息多？ 操作系统 产生死锁的必要条件？ 解决死锁的方法？ Java 了解hashmap吗？hashmap为什么初始化长度是2的幂次方？ hashmap和concurrenthashmap的区别？为什么说hashmap是线程不安全的？concurrenthashmap是怎么解决线程不安全的？ synchronize属性和synchronize方法有什么区别？ 算法 求一个大数据集里面前k个最大的数？ 求一个大数据集里面前k个出现次数最多的数？ 最右视频（一面挂）扯淡 先自我介绍一下吧。 你第一个项目是深度学习的，我对这方面是个外行，你怎么向我介绍这个东西？ 你第二个项目是前端开发，能说说都用到什么技术吗？说了HTML网页+echarts图表，用JavaScript写的，数据是自己模拟的（因为甲方没给数据。面试官说就是都是死数据咯。我又补充如果有数据我们也可以使用mybatis传？面试官眼前一亮，你现在是使用了mybatis了？（回答还没。。。尬住了 你这两个项目都不是完全是测试的，那你说你熟悉测试理论，能说说都知道什么理论吗？（随便答了两句黑盒白盒，等价类划分，正等着面试官深入问，结果直接说可以了，下一题？内心os：等等，我还没描述黑白盒测试的区别，还没介绍单元测试、集成测试、系统测试、回归测试 我给你一个场景，有一份工作量是5天的任务，老板要你2天做完，你怎么办？ 遇到技术难点怎么办？ 老板给你指定一个同学（同事，笑），你去向他请教，你会怎么请教？ 你觉得你的社交能力怎样？实习有一个团队一起协作，你作为一个新人怎么融入？ 你觉得你的抗压能力怎样？ 你的职业规划是什么？ 你都面试了哪些公司？（说算上这次是第二次）就继续问说说你上一家，我说是美团，又继续问面的是测试还是开发，我说也是测试开发。最后问了一嘴美团都面了什么内容。（其实是我自己脑补，自顾自答得。。。 你觉得测试是干嘛的？为什么选择测试？你有投过开发吗？为什么不选开发？ 大概什么时候到岗？能工作多长时间？ 技术 更加熟悉哪门语言？java还是python？（答java，感觉面试官顿了一下，沉吟一声就开始了 接口和抽象方法的区别？ ArrayList和LinkedList的区别？ 用过什么linux命令 说一下原子性？ 数据库事务的四大特性？（刚刚说的原子性算一个、半天憋出一个隔离性，实在不好意思，面试官还安慰我说基础概念确实，没关系。 java八大基础类型，（平时匆匆扫一眼的恶果，漏了short、long、byte，看我说到Boolean像是忘了，面试官直接说可以了（哈哈哈~嗝 总结 语言组织得不太好，磕磕绊绊，还是面得少了。 思路前后逻辑最好能够统一，不要紧张，冷静梳理1、2、3点再好好回答。 争取一次性把自己想说的都说完，这次面试官没怎么深入问，估计是觉得我只能答上那些，很多问题还没来得及展开就被说“可以了”，ε=(´ο｀*)))唉，下次一定学着引导展开，不然不是白白准备了吗。。 以为一面会有很多技术的问题，但可能觉得我项目经历太过简单，也没什么好问的。问了一大堆我没想过的那种问题 感觉是刷KPI的？ 纷享销客一面 先自我介绍一下 没问项目 你说你选修了软件测试这门课程，输出了相关的文档，那么你都用到哪些测试方法呢？ 更倾向做简单的黑盒测试还是喜欢有技术挑战一点的工作？ git熟悉吗？怎么用的？ linux都用到了哪些命令？ 对于日志文件有没有筛选？怎么筛选的？ 对于单元测试，除了Junit还用过别的框架吗？（面试官说工作用的tensor什么的，大同小异 java和python哪个更熟悉？ 部门情况 不只是测试，不是简单的点点点，也有开发，要写代码 工作性质：可以选择到业务部门了解，也可以直接来就上手干，跟我干 偏底层，关于接口测试，（我：集成测试？他：可以这么理解 微服务开发的内容 反问 您对我这次面试怎么评价？（虽然没深入问技术，但挺好的，基础好，值得培养 大概多久能接到面试结果通知？（结果其实已经回答我了，很快会电话通知我二面，是主管面 为了应对接下来的面试和实习，我该怎么准备？（简历写的东西加强一下，sql语句必考连表查询之类的多准备一下，算法题刷题就完事了，代码能力加强一些，可以自己做一些微服务的东西。 纷享销客二面（offer）QA面试官估计是忘了我，等了10min打了个电话，然后全程用手机视频面 自我介绍？ 对测试了解？ 更愿意做白盒还是黑盒？ 接口测试做过吗？（postman测过百度翻译接口，当时是面完一面之后百度了接口测试，跟着博客试了一下 针对你的百度翻译接口测试，设计测试用例？ 你都是站在用户角度设计的，有考虑过开发人员的测试用例吗？ 有什么想问的？ 百度一面，50min 自我介绍 问项目，没什么好问的，尬聊 linux命令介绍一下 linux查找cpu占用前五的进程？ 把文本内容aa全部替换成bbb 数据库：查找平均分大于60的学生及其成绩，查找倒数第三个入职的员工信息 从点击一个网页到显示的全过程？ get和post的区别？ cookie和session的区别？ 查找两个链表第一个相同结点？ 判断链表是否有环？ 测试的理解？ 听说过测试金字塔吗？ 有什么想问的？ 百度二面，50min 6.11（周五）下午2点面的，接下来的周六、日、一是端午节 自我介绍 共享屏幕，直接写代码：一个文件里面有学生的信息：学号、姓名和年龄。你写java代码，对学生进行去重和排序处理，然后连接数据库，将每个学生的信息插入。（15min 写完了，讲一下，如果你对刚刚这个功能进行测试，你会怎么测？ tcp和udp区别？tcp具体怎么保证可靠性（又问了很多计算机网络的知识，感觉很喜欢问计网 linux查找日志中出现次数最多的10个ip地址？用到了哪些命令？（cat、sort、head、|…) 你今天下午还有课吗？（答没有，原来是面完10min后打电话约三面 有什么想问的？ 我投的是测试开发吧？（因为发给我的二面链接写的后台开发，同时问的问题太过诡异 工程效能部是干什么的？ 我能学到什么？ 百度三面，40min 自我介绍一下 二面面试官都问你什么了？ 又问了一些，但是忘了 网络、操作系统都问的差不多了，我们做道题吧，查找最长无重复子串（写了快20 min，紧张 你有什么想问的？ 百度四面（offer） PS：前面三面都是视频面，我以为这次电话面应该是hr了吧，聊着聊着不对劲 同学你好，前面的面试官说你不错，你感觉怎么样？ 还在北京上学是吗？大三？考研吗？ 最快入职时间？能实习多久？（暑假一周5天没问题，面试官说大四开学后根据课程调整也是可以的，我说我下学期就一节课，不需要调整hhh 能保证6个月以上实习吗？（我说能，顺便探探口风，看能不能转正，说有很大机会，我也表示我也希望实习久点balabala 家里人知道实习，支持吗？学校支持吗？ 建议我多学校老师沟通（这里不是很懂，是有传闻交大的老师不放人吗？我解释说老师很支持，暑期课程就有用实习抵学分的。 你学习过程中有遇到什么困难吗？怎么解决的？ 和同学关系怎么样？（因为我上一个问题说问身边的dalao 然后话题陡然一转，你java怎么学的？ python怎么学的？掌握情况如何？ 面试官介绍了一下部门的情况，说会比较多使用python 数据库平时有用吗？怎么用的？ 了解主从同步吗？（？？？后面还有一些问题我忘了，我已经神志不清了 你有什么想了解的？ 实习生在部门日常工作都干些什么？ 百度里面培养体系如何？ 面试结果？ 这里他说他也是技术人员，主要是打电话了解情况，说具体入职时间、待遇等hr通知 最后面试官祝我端午节快乐（我说今天怎么连着面，原来是端午节等下班没事干2333 我说：端午节快乐！88 面完快下午5点，出去吃个饭，拿个快递，回宿舍后不久（7点多）收到hr电话 字节一面，50min 自我介绍 项目 大创项目遇到什么困难怎么解决的？ 数据库用过吗？（MySQL 怎么查找一张表中的前10条记录（limit 索引用过吗？（说用过b+树和hash，面试官根本不理我，也没有顺着问 主键和索引区别？唯一索引听过吗？ 删除一张表有用过吗？ delete、drop、truncate的区别？ 事务知道吗？ 了解数据库引擎吗innoDB还有my…my…my（似乎想等我补充，我保持微笑，空气凝固半天后，我说我不知道myISAM 操作系统了解吗？ 使用命令查找一个叫a的文件中所有“中国”字段？ 使用命令将文件a中所有“中国”替换成“北京”？ 进程和线程区别？ 并行和并发区别？ 我为什么能够一边写代码，一边视频面试，甚至还能同时听歌？ 网络了解吗？ tcp和udp区别？ 为什么tcp可靠？ 流量控制是什么？拥塞控制是什么？ cookie和session区别？ 状态码了解吗？200？404？302？301？500？ http和https区别？SSL协议了解吗？说一下实现原理。 输入网址按下回车到网页展示的过程？ java比较熟悉？用过String吗？StringBuffer、StringBuilder区别？ String为什么是不可变的？源码看过吗？ StringBuffer为什么是线程安全的？ 垃圾回收了解吗？说一下jvm？ 做两道算法题？ 判断数字是否是回文数字？ 合并重叠区间（用的贪心 字节二面，60min 面试官黑眼圈比我还重，我很担忧… 自我介绍 简单讲一下你写的web页面？数据写死的吗？ 前后端的项目有吗？（答数据库课程设计 怎么做的？（仿美团的 对于前端页面无法正确显示（例如空白页）你都怎么排查？ 用到什么接口？接口传参有了解吗？（必传和非必传 入参校验有做过吗？ http接口用过吗？ url发送一个请求，请求接口有了解吗？（很喜欢问接口呀 解析URL？ tcp连接？ https了解吗？ get和post区别？ 怎样屏蔽网络，不让某些人访问一些特定的网站？除了使用防火墙，根据你学的网络知识还有别的方法吗？ jvm了解吗？垃圾回收机制？内存模型？ 内存溢出了解吗？一般报什么错误？故障排查？ 评价一下你的数据库水平？ 了解Redis吗？ 连表查询？left join、right join、inner join区别？ 线程的一个问题（听都没听懂），说可以多了解一下 常用linux命令？（重定向 筛选日志信息，把info、void字段去掉，只保留错误信息？ 测试一个水杯？（xxx，还有吗？xxx，还有吗？xxx，还有吗？面试官最后补充了兼容性测试 你说你对软件测试感兴趣，能具体说说吗？你认为测试是做什么的？ 做道编程题？（好.. 删除链表倒数第k个节点并返回头结点？ 牛客网提交不了（面试结束后和牛客客服排查，发现是我这个智障写了两个public类，牛客输入输出的模式还是不熟悉，下次不刷LeetCode了，直接acm搞起 一边等客服回复，一边和面试官讨论算法边界问题，怎么做特判（链表为空？k比链表长度大？只有一个节点？k恰好等于链表长度？ （这是在我反问之后问的几个问题：场面一度很混乱 等等，我帮hr问几个问题：考研吗？ 暑期实习还是长期实习？ 能全勤实习吗？ 反问 应该不是测试，还是测试开发？（对滴 什么部门？（中台 平时工作内容？（白盒，有访问开发代码的权限，进行代码检查，语句覆盖——)优化 总结 面足一个小时，虽然很多东西我都不知道（逃… 字节一面和二面都会记录，区别是一面面试官经常敲键盘半天，二面感觉虽然也在记录，但是面试过程很丝滑，没有那种长时间的卡顿，很舒服。 这次面试体验很好，我发现一个有趣的现象，字节的面试喜欢层层递进。（虽然深入问我就不会了… 问问题还会先问一下你对这方面的了解情况，经常是：你对xxx了解如何？然后据此扒拉一会再问，估计是内部题库（好想要一份… 很会引导，应该是我目前遇到最会问问题的了，在我卡壳时还帮我梳理思路，很感谢！ 面试官有时候嘴瓢，然后自己笑一下。我觉得还挺好看的，就顺手截了个图。 晚上快7点时hr通知三面 字节三面，50min 晚上还有考试，难顶 自我介绍 为什么对测试感兴趣？具体点，再具体点，我还是不理解怎么这就能说明你感兴趣了？ 淘宝为什么只登陆一次就后续不用再登陆？用到什么技术？ sessionID怎么来的？怎么就生成了？ 就当现在生成了，怎么发送的？从哪发？发到哪里？ 服务器怎么存储的？ 换个问题，你买过火车票吗？ 哪到哪？（北京到珠海 现在要查询北京到珠海的列车号，出发站还有终点站，你怎么做？ 你说查数据库，怎么查？ 你这只能查从北京始发，珠海终点的，经停站有北京和珠海的火车也要查询出来，怎么做？ 你数据库的表怎么定义的？表都没有你就查了？ 你说把全国所有城市两两组合，全国有多少个城市？（顺口说了34，结果被说34那是省份hhh 就当每个省20个城市，C{600，2}有上万种可能，你觉得效率怎样？ 你说对数据预处理，怎么处理，别光靠猜啊？ 换个问题，ipv4地址知道吗？ 为什么要划分A、B、C？还有D、E吗？ 反正ip地址是唯一的，全世界区分开不就好咯？划分来干嘛？ 写一个程序，判断输入字符串是否是ipv4地址？ 反问 部门？（电商、直播带货 面试欠缺的，未来学习方向？（无可奉告，还补充说是hr强调不能说这方面 总结 Talk is cheep, show me your code.","categories":[{"name":"面试","slug":"面试","permalink":"http://oceanmiki.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"http://oceanmiki.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计网","slug":"计网","permalink":"http://oceanmiki.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://oceanmiki.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-04-16T04:08:42.904Z","updated":"2020-04-16T13:26:57.429Z","comments":true,"path":"2020/04/16/正则表达式/","link":"","permalink":"http://oceanmiki.github.io/2020/04/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"还记得第一次在知乎上看到正则表达式，看了半天都只是学了些皮毛，还转眼就忘。今天看了廖雪峰老师的教程，总结一下。","text":"还记得第一次在知乎上看到正则表达式，看了半天都只是学了些皮毛，还转眼就忘。今天看了廖雪峰老师的教程，总结一下。 匹配规则字符表示 特殊字符需要转义 &quot;a\\&amp;b&quot; 由于Java中 \\ 也需要转义，所以要写成 &quot;a\\\\&amp;b&quot; 不确定是否需要转义的加上双斜杠总没错。（下面不再重复说明） 对于非 Ascll 字符（例如中文）用16进制表示，例如 &quot;a\\\\u548cc&quot; 匹配 “a和c” 小数点 “.” 用来匹配任一字符，但该匹配位置必须有一个字符，不能为空。注意：小数点前不要加双斜杠进行转义，否则只能匹配小数点 “.” 这个字符 “\\\\d” 匹配 “0~9” 的一个数字 “\\\\w” 匹配一个字母、一个数字或一个下划线”_” “\\\\s” 匹配一个空白字符（一个空格或一个Tab即“\\t”） “\\\\D” 匹配一个非数字，同理 “\\\\W” 匹配一个非 “\\\\w”、”\\\\S” 匹配一个非 “\\\\s” 修饰符 星号 * 修饰在它前面的字符，匹配任意个数（包括0）的该字符 加号 + 修饰它前面的字符，匹配至少一个（不包括0）个数的该字符 问号 ? 修饰它前面的字符，匹配 1 个或 0 个该字符 {n} 修饰它前面的字符，匹配 n 个该字符 {n,m} 修饰它前面的字符，匹配 n 到 m 个该字符 {n,} 修饰它前面的字符，匹配至少 n 个该字符 {0,n} 修饰它前面的字符，匹配至多 n 个该字符 分组匹配规则使用小括号进行分组正则表达式字符串编译为 Pattern 对象反复使用一个正则表达式字符串进行快速匹配效率较低 使用Match.group(n)快速提取子串123456789101112//匹配一个24小时形式的时间Pattern pattern = Pattern.compile(\"^([0-1][0-9]|[2][0-3]):([0-5][0-9])$\"); Matcher matcher = pattern.matcher(\"20:27\"); if(matcher.matches())&#123; String whole = matcher.group(0); //0表示获取全部匹配的字符串 String hour = matcher.group(1); //1表示获取匹配的第一个小括号包着的字符串 String min = matcher.group(2); //2表示获取匹配的第二个小括号 System.out.println(\"whole: \" + whole);//20:27 System.out.println(\"hour: \" + hour);//20 System.out.println(\"min: \" + min);//27 &#125; 多说两句，这里Pattern里的 “^” 表示从头开始匹配，“$” 表示到这里匹配结束，由于Java中默认单行匹配，因此可写可不写。（所以不写） 复杂匹配规则 竖线 “|” 是 “或” 的意思 “[…]” 匹配中括号 [] 范围内的字符，且只能匹配其中一个。例如：[ac] 匹配一个 a 或 c、 [0-5] 匹配一个范围在 0 到 5 之间的数字 拓展一下，”[a-f0-9]{6}” 匹配16进制表示的颜色，当然也可以写成 “([0-9]|[a-f]){6}”， [^…] 匹配非范围内的字符 非贪婪匹配正则表达式默认使用贪婪匹配，即尽可能多的向后匹配 使用问号 ? 实现非贪婪匹配注意区分 “\\\\d??”，第一个问号表示匹配 0 个或 1 个数字，第二个问号表示非贪婪匹配，所以合起来就是匹配 0 个数字 搜索和替换分割字符串 单个空格 String[] arr = &quot;a b c&quot;.split(&quot;\\\\s&quot;) 如果其中使用一个或多个空格分隔，改为 “\\\\s+” 即可 如果其中还使用逗号 “,” 、分号 “;” 等其他字符分隔，还可以进一步改写成 “[\\\\s\\,\\;]+” 搜索字符串123456789101112String s = \"Happiness is a way station between too much and too little.\"; Pattern pattern = Pattern.compile(\"\\\\w+a\\\\w+\"); Matcher matcher = pattern.matcher(s); while (matcher.find()) &#123; String sub = s.substring(matcher.start(), matcher.end()); System.out.println(sub); &#125; //找到英文句子中所有包含字母a的单词 Happiness way station 替换字符串1、将多个空格替换成一个空格，更符合英文句子规范 123String s = \"Happiness is a way station between too much and too little.\"; String s1 = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(s1); 2、给每个单词加粗 1String s2 = s1.replaceAll(\"(\\\\w+)\", \"&lt;b&gt;$1&lt;/b&gt;\"); 正则表达式给 “\\\\w+” 加上小括号表示选中，后面的 $1 表示反向选中获取到的每个单词，然后给它加粗","categories":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/categories/Java/"}],"tags":[]},{"title":"KMP算法","slug":"KMP算法","date":"2020-03-29T04:27:21.866Z","updated":"2020-03-29T13:05:22.366Z","comments":true,"path":"2020/03/29/KMP算法/","link":"","permalink":"http://oceanmiki.github.io/2020/03/29/KMP%E7%AE%97%E6%B3%95/","excerpt":"KMP算法当匹配到不同的字符时，不是像暴力匹配那样从一开始的位置的后一位比较，而是聪明地跳过已经比较过的字符串。","text":"KMP算法当匹配到不同的字符时，不是像暴力匹配那样从一开始的位置的后一位比较，而是聪明地跳过已经比较过的字符串。 部分匹配值前缀和后缀给定一个字符串： bread 前缀：b，br，bre，brea 后缀：read，ead，ad，d 部分匹配值就是前缀和后缀的最长共有字符的长度。 以“ABCDABD”为例： “A”的前缀后缀都为空，部分匹配值是0， “AB”的前缀是“A”，后缀是“B”，部分匹配值是0， …… “ABCDA”前缀是[“A”,”AB”,”ABC”,”ABCD”]，后缀是[“BCDA”,”CDA”,”DA”,”A”]，最长共有字符是“A”，长度是1，部分匹配值是1 “ABCDAB”前缀是[“A”,”AB”,”ABC”,”ABCD”,”ABCDA”]，后缀是[“BCDAB”,”CDAB”,”DAB”,”AB”,”B”]，最长共有字符是“AB”，长度是2，部分匹配值是2。 …… 很容易就得到”ABCDABD”的部分匹配表： A B C D A B D 0 0 0 0 1 2 0 注意部分匹配值是相对于字符串来说的，不是说字符“D”的部分匹配值是0，而是“ABCDABD”的部分匹配值是0。 算法实现子串作为搜索词，得到搜索词的部分匹配表。 遇到不匹配字符时，移动位数 = 已经匹配字符长度 - 对应的部分匹配值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class KMPalgorithm &#123; public static void main(String[] args) &#123; String str1 = \"BCD ABCDAB ABCAB ABCABCDABD\"; String str2 = \"ABCDABD\"; int[] next = next(str2); int index = search(str1,str2,next); System.out.println(index);//20 &#125; //搜索算法 /** * @param str1 母串 * @param str2 子串 * @param next 部分匹配表 * @return 存在则返回第一个子串出现的位置，不存在就返回-1 */ public static int search(String str1, String str2, int[] next) &#123; //遍历，在暴力法的基础上改进 for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123; //先处理不相等的情况 while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123; j = next[j - 1];//妙不可言 &#125; if (str1.charAt(i) == str2.charAt(j)) &#123; j++;//如果当前字符相等，就继续比较下一个。 &#125; if (j == str2.length()) &#123;//说明找到了 return i - j + 1;//返回第一个子串出现的位置。由于i比j少一次++，所以再+1补上 &#125; &#125; return -1;//遍历过程中索引j没有到达str2的最后一个字符，说明不存在。 &#125; //得到一个字符串（子串）的部分匹配表 /** * @param dest 子串 * @return 返回子串的部分匹配表 */ public static int[] next(String dest) &#123; //创建一个和字符串长度相等的数组 int[] next = new int[dest.length()]; next[0] = 0;//第一个位置只有一个字符，部分匹配值当然是0 for (int i = 1, j = 0; i &lt; dest.length(); i++) &#123;//i = 1，从第二个字符开始求部分匹配值。 //先处理不相等的情况，直到相等 //循环终止条件就是直到索引j回到和i对应的字符相同的位置 while (j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123; j = next[j - 1];//妙不可言 &#125; //对应的部分匹配值加1 if (dest.charAt(i) == dest.charAt(j)) &#123; j++; &#125; next[i] = j; &#125; return next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"String","slug":"String","permalink":"http://oceanmiki.github.io/tags/String/"}]},{"title":"理解String的不可变性","slug":"理解String的不可变性","date":"2020-03-15T04:12:54.989Z","updated":"2020-03-29T03:19:19.895Z","comments":true,"path":"2020/03/15/理解String的不可变性/","link":"","permalink":"http://oceanmiki.github.io/2020/03/15/%E7%90%86%E8%A7%A3String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/","excerpt":"一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。","text":"一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。 字面量方式创建String字符串重新赋值12345String s1 = \"abc\";String s2 = \"abc\";//此时s1 == s2s1 = \"hello\";//s2还是abc，s1变成了hello 通过字面量的形式给一个字符串赋值，此时字符串值声明在方法区的字符串常量池中。 字符串常量池不会存重复的字符串（即内容相同的字符串）。 一开始没有abc，就创建了一个abc，s1指向这个abc。s2也要指向abc，但是常量池中已经有了abc，就不要再新建一个abc了，直接让s2指向s1指向的abc，所以s1和s2的地址是相等的。 接着对s1重新赋值，并不是把s1指向的abc改成hello，而是新创建了一个hello，让s1指向新创建的hello。s2还是指向原来的abc。 字符串的连接1234String s3 = \"hello\";//很明显现在s1 == s3s3 += \" world!\";//s3变成了\"hello world!\"，s1还是hello 字符的替换123String s4 = \"abc\";String s5 = s4.replace('a','m');//把a换成m//s5是mbc，s4还是abc 不难发现，连接和替换都是重新创建了新的字符串，不能在原有的字符串上修改。 为什么要有不可变性你本来有一个字符串s1，又新创建了一个字符串s2。一开始使他们指向同一个字符串，后来s2变了，我们不希望s1也跟着改变。 String对象的创建和 String str = &quot;hello&quot; 不一样，new一个String对象是放在堆里面的。 123String s1 = \"hello\"; String s2 = new String(\"hello\"); System.out.println(s1 == s2);//false s1首先在方法区的字符串常量值中创建了hello，s2指向堆里面开辟的一个空间。String是引用类型，堆里面存储的也是一个地址，这个地址指向常量池中的hello。 那么问题来了， String str = &quot;abc&quot; 创建了几个对象？ 答案是两个，一个是堆空间中new的，另一个是final的char[]数组对应在常量池中的数据“abc”。 但是如果常量池中本来就有abc，是不会再次声明的。因为常量池不存放重复的字符串。 String不同拼接方式对比123456789String s1 = \"abc\"; String s2 = \"hello\"; String s3 = s1 + s2; String s4 = \"abchello\"; String s5 = \"abc\" + \"hello\"; String s6 = s1 + \"hello\"; System.out.println(s3 == s4);//false System.out.println(s5 == s4);//true System.out.println(s6 == s4);//false 拼接的时候只要有一个变量参与，就相当于new一个String对象，new出来的对象放在堆中，地址都不同。 两个字面量（常量）拼接的s5，还是在常量池中创建的。但是常量池已经存在了，所以s5和s4指向同一个字符串，地址也就一样了。 如果拼接的结果调用 intern（）方法，返回值指向常量池中的地址。","categories":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/categories/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"http://oceanmiki.github.io/tags/String/"}]},{"title":"HTML基础","slug":"HTML基础","date":"2020-02-29T04:03:38.022Z","updated":"2020-03-03T05:10:04.665Z","comments":true,"path":"2020/02/29/HTML基础/","link":"","permalink":"http://oceanmiki.github.io/2020/02/29/HTML%E5%9F%BA%E7%A1%80/","excerpt":"I know HTML !","text":"I know HTML ! 超链接1&lt;a href=\"地址\" target = \"_blank\"&gt;超链接对象&lt;/a&gt; _blank：另起一个窗口打开新网页 _self：在当前窗口打开新的网页链接（默认） 表格123456789101112131415&lt;table width = \"500\", height = \"500\" cellspacing = \"0\" border = \"1\" &gt; &lt;tr&gt; &lt;th colspan = \"2\"&gt;1.1&lt;/th&gt; &lt;th&gt;1.2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; cellspacing 设置单元格间距 border 设置表格线，如果不写就没有表格的框架线条 colspan 设置单元格跨行，rowspan设置跨列 tr是行，td是列，th表示单元格里面加粗居中 表单1234567891011121314151617&lt;form&gt; 用户名: &lt;input type=\"text\"&gt;&lt;br/&gt; 密码: &lt;input type=\"password\"&gt;&lt;br/&gt; 性别: &lt;input type=\"radio\" name=\"sex\" checked = checked&gt; 男 &lt;input type=\"radio\" name=\"sex\"&gt; 女&lt;br/&gt; 兴趣爱好: &lt;input type=\"checkbox\" checked = checked/&gt;Java&lt;input type=\"checkbox\"/&gt;python&lt;input type=\"checkbox\"/&gt;c++&lt;br&gt; 国籍: &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt; &lt;option selected = selected&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;日本&lt;/option&gt; &lt;/select&gt;&lt;br&gt; 自我评价： &lt;textarea rows=\"10\" cols=\"20\"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type=\"reset\"&gt; &lt;input type=\"submit\"&gt; &lt;input type=\"file\" &gt; &lt;input type=\"hidden\"&gt;&lt;/form&gt; radio是单选 checkbox是多选 checked = checked是默认选择，selected同理 为了美观，可以把表单放在表格里面，第一列放文字信息，第二列放内容 表单提交的细节123456789101112131415161718&lt;form action=\"http://www.baidu.com\" method=\"get\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 密码: &lt;input type=\"password\" name=\"password\"&gt;&lt;br/&gt; 性别: &lt;input type=\"radio\" name=\"sex\" value=\"man\"&gt; 男 &lt;input type=\"radio\" name=\"sex\" value=\"woman\"&gt; 女&lt;br/&gt; 兴趣爱好: &lt;input type=\"checkbox\" name=\"hobby\" value=\"java\"&gt;Java &lt;input type=\"checkbox\" name=\"hobby\" value=\"py\"&gt;python &lt;input type=\"checkbox\" name=\"hobby\" value=\"cpp\"&gt;c++&lt;br&gt; 国籍: &lt;select name=\"nation\"&gt; &lt;option value=\"null\"&gt;--请选择国籍--&lt;/option&gt; &lt;option value=\"cn\"&gt;中国&lt;/option&gt; &lt;option value=\"us\"&gt;美国&lt;/option&gt; &lt;option value=\"jp\"&gt;日本&lt;/option&gt; &lt;/select&gt;&lt;br&gt; 自我评价： &lt;textarea rows=\"10\" cols=\"20\" name=\"desc\"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type=\"reset\"&gt; &lt;input type=\"submit\"&gt; &lt;input type=\"file\" name=\"file\"&gt;&lt;/form&gt; form标签是表单标签 action是请求提交的服务器地址 method是提交的方式，get / post 隐藏域hidden，用来处理不需要给用户看的，但要传给服务器的信息（比如告诉服务器这个表单是用户注册的信息login） 表单提交后，数据没有发送给服务器可能情况 表单项中没有name属性（input ，select，textarea…） 单选，多选（下拉列表中的option标签）都需要设置 value ，以便服务器识别选项 提交的内容不在表单中 get请求的特点123456789101112https:&#x2F;&#x2F;www.baidu.com&#x2F;?username&#x3D;冷亚麻色的&amp;password&#x3D;123456&amp;sex&#x3D;man&amp;hobby&#x3D;java&amp;hobby&#x3D;py&amp;nation&#x3D;cn&amp;desc&#x3D;xxx 浏览器地址栏中的的地址是：action属性+（？请求参数） 请求参数格式name=value&amp;name=value…. 不安全 有数据长度的限制 post请求的特点 浏览器地址栏中只有action属性 相对于get更安全 理论上没有长度限制","categories":[{"name":"前端","slug":"前端","permalink":"http://oceanmiki.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://oceanmiki.github.io/tags/JavaWeb/"},{"name":"HTML","slug":"HTML","permalink":"http://oceanmiki.github.io/tags/HTML/"}]},{"title":"链表技巧：快慢指针","slug":"链表技巧：快慢指针","date":"2020-02-16T14:24:55.546Z","updated":"2020-02-22T15:02:20.044Z","comments":true,"path":"2020/02/16/链表技巧：快慢指针/","link":"","permalink":"http://oceanmiki.github.io/2020/02/16/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","excerpt":"现在有一个单向链表，不知道长度，怎么利用更短的时间找到中间值呢？先遍历一次，计算出链表长度n，再移动 n / 2 次找到中间值？是不是感觉有点憨批？","text":"现在有一个单向链表，不知道长度，怎么利用更短的时间找到中间值呢？先遍历一次，计算出链表长度n，再移动 n / 2 次找到中间值？是不是感觉有点憨批？ 单向链表的中间节点我们可以定义一个慢指针 slow 和一个快指针 fast 。现在每次让 fast 移动 2 次，同时 slow 只移动 1 次。那么当 fast 移动到末尾时，slow 刚好“走到”中间！ 12345678910111213141516171819/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125;&#125; 移动的时候，因为 fast 每次都移动 2 次，所以要小心出现空指针错误，用之前写的翁恺老师讲的方法（类似c嘛）：.next前面的都要检查非空。是不是一下子就看出循环的判读条件了？slow肯定是比 fast 要慢的，就不要再判断了！ 判断链表是否有环和上面一样，slow移动 1 次，fast 移动 2 次。如果链表有环，最终 fast 和 slow 会相遇。如果链表没有环，fast会走到null，这时候返回 false 即可。 12345678910111213141516public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null)&#123; return false; &#125; ListNode fast = head.next.next; ListNode slow = head.next; while( slow != fast)&#123; if(null == fast || null == fast.next) return false; fast = fast.next.next; slow = slow.next; &#125; return true; &#125;&#125; 当然，链表为空或只有一个节点，肯定是没有环的（什么？你说head.next = head?） 倒数第k个节点这次 fast 和 slow 每次都只移动 1 下。但首先让 fast 先移动 k 次。当 fast 走到null时，slow就走到倒数第 k 个节点。 12345678910111213141516class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; for(int i = 0; i &lt; k ;i++)&#123; fast = fast.next; &#125; while(fast != null)&#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://oceanmiki.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://oceanmiki.github.io/tags/LeetCode/"}]},{"title":"旋转链表","slug":"旋转链表","date":"2020-02-16T09:19:02.621Z","updated":"2020-02-16T09:19:02.621Z","comments":true,"path":"2020/02/16/旋转链表/","link":"","permalink":"http://oceanmiki.github.io/2020/02/16/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。","text":"给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 问题示例示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 代码实现官方题解 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || head.next == null)&#123; return head; &#125; ListNode old_tail = head; int n; for(n = 1; old_tail.next != null; n++) old_tail = old_tail.next; old_tail.next = head; ListNode new_tail = head; for (int i = 0; i &lt; n - k % n - 1; i++) new_tail = new_tail.next; ListNode new_head = new_tail.next; new_tail.next = null; return new_head; &#125;&#125; 思路总体思路：先形成环形链表，找到旋转后新的链表头和链表为，最后断开。 先用一个辅助指针old_tail遍历链表，找到最后一个节点。 然后让此时的old_tail的next指向head，形成环形链表。 接下来就是找到旋转后的链表的尾部（new_tail）。通过示例发现可以让old_tail向左移动k次找到。 可这是一个单向链表。一开始我想，简单啊，反转链表不就行了？ 然后就没有然后了，反转了之后，新的链表头就找不到了，不妥。（脑海有一个声音：再反转一次！） 转换一下，old_tail向左移动k次，等价于head向右移动 n-k-1 次。 新的问题来了，当k大于n的时候岂不是移动负数次了吗？ 这时，我想起了之前用数组模拟环形队列的时候，可以用取余来解决。 所以，将 k%n 。得到的数一定小于n，问题解决！perfect！ 找到新的链表尾部，它的next就是新的链表头。 最后记得把链表断开，不要旋转完把单链表变成环形链表！","categories":[{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"环形链表","slug":"环形链表","permalink":"http://oceanmiki.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"name":"力扣","slug":"力扣","permalink":"http://oceanmiki.github.io/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"约瑟夫问题","slug":"约瑟夫问题","date":"2020-02-15T12:24:26.762Z","updated":"2020-02-15T12:24:26.763Z","comments":true,"path":"2020/02/15/约瑟夫问题/","link":"","permalink":"http://oceanmiki.github.io/2020/02/15/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/","excerpt":"那一天，人类终于回想起了，曾经一度被猴子选大王支配的恐怖，还有不会链表的那份耻辱。","text":"那一天，人类终于回想起了，曾经一度被猴子选大王支配的恐怖，还有不会链表的那份耻辱。 问题描述一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第k号开始报数，每轮从1报到m，凡报到m的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？ 输入格式：在一行中给三个正整数。N（≤1000）代表有N只猴子，k（1≤k≤N）代表从第k只猴子开始报数，m（1≤m≤1000）代表报m个数。 输出格式：在一行中输出当选猴王的编号。 输入样例：5 1 2 输出样例：3 代码实现环形链表模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.util.Scanner;class circleList&#123; private Monkey first = null; public Monkey cur = null; public void init(int nums)&#123; if(nums &lt;= 0)&#123; throw new RuntimeException(\"Input is invalid!\"); &#125; for (int i = 1; i &lt;= nums ; i++) &#123; Monkey monkey = new Monkey(i); if (i == 1)&#123; first = monkey; first.setNext(first); cur = first; &#125;else &#123; cur.setNext(monkey); monkey.setNext(first); cur = monkey; &#125; &#125; &#125; public void show() &#123; if (first == null) &#123; System.out.println(\"No monkeys!\"); &#125; Monkey cur = first; while (true) &#123; System.out.print(cur.getNo() + \" \"); if (cur.getNext() == first) &#123; break; &#125; cur = cur.getNext(); &#125; &#125; public void selectKing(int k, int m,int n)&#123; Monkey last = first;//定义一个辅助指针找到并指向环形链表的最后一个节点 //防止傻逼 if(first == null || k &lt;= 0 || k &gt; n || m &lt;= 0)&#123; System.out.println(\"Your input is illegal！\"); return; &#125; //首先让first移动k-1次找到开始报数的位置 for (int i = 1; i &lt; k ;i++)&#123; first = first.getNext(); &#125; //当last的next是first时说明此时的last就是环形链表的最后一个 while (last.getNext() != first)&#123; last = last.getNext(); &#125; int index = 1;//记录出局猴子的顺序 //如果last == first说明圈里面就剩下一只猴子了 while (first != last)&#123; //报数，因为first本身也要报一个数，所以只要移动m-1次 for (int i = 1; i &lt; m ; i++)&#123; first = first.getNext(); last = last.getNext();//last也要跟着移动 &#125; System.out.printf(\"第%d个出局的猴子编号是%d\",index,first.getNo()); index++; System.out.println(); //删除出局猴子的节点 first = first.getNext(); last.setNext(first); &#125; System.out.printf(\"大王是%d\",first.getNo()); &#125;&#125;class Monkey&#123; private int no; private Monkey next; public Monkey(int no) &#123; this.no = no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Monkey getNext() &#123; return next; &#125; public void setNext(Monkey next) &#123; this.next = next; &#125;&#125;public class johnphuTest &#123; public static void main(String[] args) &#123; int n, k, m; Scanner scanner = new Scanner(System.in); circleList list = new circleList(); System.out.println(\"有多少个猴子？\"); n = scanner.nextInt(); System.out.println(\"从第几只猴子开始报数？\"); k = scanner.nextInt(); System.out.println(\"每次报几个数？\"); m = scanner.nextInt(); list.init(n); list.selectKing(k,m,n); &#125;&#125; 说明定义猴子节点的时候把猴子的编号都声明为private，所以使用了getter和setter方法，代码阅读性略有下降，不过不是太影响。 为了交互性，加入了一些文字提示。 算法核心就是，定义两个指针，一个找到开始报数的猴子（first），一个找到环形链表最后的猴子（last）。当两个指针重合，说明就剩下一只猴子了。 报m个数就是让两个指针一起向next移动m-1次，报完数时first的指向就是要淘汰的猴子。 淘汰猴子时，就让first指向下一只猴子（也就是要淘汰的猴子的next），然后改变last的next，使last的next变成first。这样，要淘汰的猴子就没有指针指向，在Java里被垃圾回收了，相当于删除。 最后剩下的猴子就是大王。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"环形链表","slug":"环形链表","permalink":"http://oceanmiki.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"}]},{"title":"单向链表的反转","slug":"单向链表的反转","date":"2020-02-14T13:25:26.593Z","updated":"2020-02-16T13:57:11.811Z","comments":true,"path":"2020/02/14/单向链表的反转/","link":"","permalink":"http://oceanmiki.github.io/2020/02/14/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/","excerpt":"腾讯的一道面试题，将单向链表反转。","text":"腾讯的一道面试题，将单向链表反转。 声明节点123456789101112131415161718class heroNode&#123; String name; int no; heroNode next; public heroNode(String name, int no) &#123; this.name = name; this.no = no; &#125; @Override public String toString() &#123; return \"heroNode&#123;\" + \"name='\" + name + '\\'' + \", no=\" + no + '&#125;'; &#125;&#125; 链表1234567891011121314151617181920212223242526272829class singleList&#123; private heroNode head = new heroNode(\"\",0); public heroNode tail = head; public heroNode getHead() &#123; return head; &#125; public void add(heroNode newhero)&#123; tail.next = newhero; tail = newhero; &#125; public int length()&#123; heroNode temp = head.next; int cnt = 0; while (temp.next != null)&#123; cnt++; temp = temp.next; &#125; return cnt; &#125; public void show()&#123; heroNode temp = head; while (temp.next != null)&#123; temp = temp.next; System.out.println(temp); &#125; &#125;&#125; 除了头节点，我还定义了个尾节点，这样添加节点的时候就不用反复遍历链表来找到尾节点。另外，以后对双向链表的操作也更加方便（像什么逆序输出之类的）。 方式一思路首先，new一个新的头节点。 然后，将原来的链表每个节点按顺序取出，每取出一个节点就将它的next接上新的头节点的next（如果是第一个节点，接上的就是null）。 最后，将新的头节点的next接上取出的节点。 但是，上面的方法是有问题的。 发现了没有？ 取出的节点的next接上新的头节点的next之后，原来链表在取出的节点之后的所有节点都找不到了（next都变了）。 所以需要一个额外的节点，用来保存取出的节点的下一个节点。 代码实现1234567891011121314151617public void reverse1(singleList original)&#123; singleList reverseList = new singleList(); heroNode originHead = original.getHead(); heroNode cur = original.getHead().next; if(cur == null || cur.next == null)&#123; return; &#125; heroNode next = null; heroNode reverseHead = reverseList.getHead();//新的头节点 while (cur != null)&#123; next = cur.next;//保存当前节点的下一个节点，避免丢失 cur.next = reverseHead.next; reverseHead.next = cur; cur = next; &#125; original.getHead().next = reverseHead.next;//原来的头接上反转之后的链表 &#125; 原来这个函数我想不改变原来的链表，通过函数返回反转的链表，但就不是这么一个思路了，而且写出来也不好看。 为使代码更高效，如果链表为空，或者只有一个节点，就直接返回。 方式二思路利用栈的先进后出。 首先，将原链表的节点按顺序取出，每取出一个就将它压进栈中。 然后，定义一个新的链表。将栈中的节点一个个弹出，每弹出一个就接在新的链表后面。 但是，记得把弹出的节点的next置空，否则会死循环。 代码实现123456789101112131415161718192021public void reverse2(singleList oringin)&#123; singleList reverseList = new singleList(); heroNode temp = oringin.getHead().next; if(temp == null || temp.next == null)&#123; return; &#125; Stack&lt;heroNode&gt; stack = new Stack&lt;&gt;(); heroNode cur = reverseList.getHead(); while (temp != null)&#123; stack.push(temp); temp = temp.next; &#125; while (stack.size() &gt; 0)&#123; heroNode last = stack.pop(); last.next = null;//取出节点后将next域置空 cur.next = last; cur = cur.next; &#125; oringin.getHead().next = reverseList.getHead().next; &#125; 这个方法对原来链表破坏更加明显。 在取出节点的同时就将它的next置空，多亏了Java的垃圾回收机制，置空就置空了，不用我们自己手动的free掉。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"单向链表","slug":"单向链表","permalink":"http://oceanmiki.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"数组实现环形队列","slug":"数组实现环形队列","date":"2020-02-13T11:23:32.953Z","updated":"2020-02-14T13:41:34.507Z","comments":true,"path":"2020/02/13/数组实现环形队列/","link":"","permalink":"http://oceanmiki.github.io/2020/02/13/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/","excerpt":"使用数组模拟静态队列，容易造成队列假溢出，导致队列只可用一次，无法复用。如果队列可以像圆环一样，自动回到开始已经空出来的地方，那真是极好的。","text":"使用数组模拟静态队列，容易造成队列假溢出，导致队列只可用一次，无法复用。如果队列可以像圆环一样，自动回到开始已经空出来的地方，那真是极好的。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class circleQueue&#123; int size; int front, rear; int arr[]; public circleQueue(int size) &#123; this.size = size; arr = new int[this.size]; &#125; public boolean isEmpty()&#123; if(front == rear) return true; return false; &#125; public boolean isFull()&#123; if((rear + 1)%size == front) return true; return false; &#125; public void add(int n)&#123; if(isFull())&#123; throw new RuntimeException(\"The Queue is full!\"); &#125; arr[rear] = n; rear = (rear+1) % size; &#125; public int get()&#123; if(isEmpty())&#123; throw new RuntimeException(\"The Queue is empty!\"); &#125; int res = arr[front]; front = (front + 1) % size; return res; &#125; public int length()&#123; return (rear + size - front)%size; &#125; public void show()&#123; for (int i = front; i &lt; front + lenth(); i++) &#123; System.out.print(arr[i%size]+\" \"); &#125; System.out.println(); &#125;&#125; 这里用到了一点小小的算法，就是通过取余，使数组下标不会越界。 值得注意的是，构造函数里面的size初始化数组之后，得到环形队列的最大能存放个数是size-1。 这是因为环形队列预留了一个位置从而闭合成环，而预留的位置是不存放数值的。 比如，当size = 3时。初始化了一个arr[3]，环形队列最多加两个元素。开始front=0的情况下，元素最多add到arr[0]和arr[1]中。arr[2]肯定是存在的，只是它作为预留的一个位置，再想add时，队列判断已经满了，就加不了了。 假设队列中已经有两个元素，你现在get一个元素之后，front变成1，arr[0]就变成预留的位置。队列只有arr[1]中有元素，再添加的时候，就加到arr[2]中了。 变量说明front从0开始，指向队列的头。rear从0开始，指向队列尾的 后一个元素 。 与静态队列不同，取出和添加操作，移动front和rear指向的时候都要先+1再对队列的size取模。 添加的时候直接把元素放在arr[rear]，因为此时这个位置就是队列最进去的元素的下一个位置。 而移除的时候，则需要先将要取出的元素保存起来，再移动front的指向。否则，你就找不到取出的元素了。 length（）函数是用来求当前队列的有效数据的个数，不一定等于size。而且（rear+size-front）%size这个表达式中+size不可省略。因为rear-front可能是负数。 众所周知，负数模整数的余数还是负数（0除外）。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"环形队列","slug":"环形队列","permalink":"http://oceanmiki.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"}]},{"title":"数据结构基础：链表","slug":"数据结构基础：链表","date":"2020-02-12T13:04:57.765Z","updated":"2020-02-12T13:04:57.765Z","comments":true,"path":"2020/02/12/数据结构基础：链表/","link":"","permalink":"http://oceanmiki.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%93%BE%E8%A1%A8/","excerpt":"郝斌老师的数据结构，C语言实现链表的一些基本操作，不同的是加了个结构体专门指向链表的头节点和尾节点，以后操作更方便。","text":"郝斌老师的数据结构，C语言实现链表的一些基本操作，不同的是加了个结构体专门指向链表的头节点和尾节点，以后操作更方便。 声明头文件1234#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std; 结构体123456789typedef struct Node&#123; int data; struct Node *next;&#125;NODE,*PNODE;typedef struct List&#123; PNODE pHead; PNODE pTail;&#125;LIST,*PLIST; 函数声明123456789void init_List(PLIST);//初始化链表void traverse_List( LIST );//遍历链表bool is_Empty( LIST );//判断链表非空int len_List(LIST);//得到链表节点长度void sort( PLIST );//对链表排序void add( PLIST );//在末尾添加元素bool insert(PLIST plist);//插入元素bool delete_List(PLIST);//删除元素void test( LIST );//测试 主函数12345678910111213int main()&#123; LIST list; init_List(&amp;list); add(&amp;list); traverse_List(list); insert(&amp;list); traverse_List(list); delete_List(&amp;list); traverse_List(list); cout&lt;&lt;endl; cout&lt;&lt;len_List(list)&lt;&lt;endl;//最后输出链表节点个数 return 0;&#125; 功能函数链表初始化123456789101112131415161718192021222324252627void init_List(PLIST list)&#123; list-&gt;pHead = NULL; list-&gt;pHead = (PNODE)malloc(sizeof(NODE)); if(list-&gt;pHead == NULL)&#123; cout&lt;&lt;\"pHead malloc failed!\"&lt;&lt;endl; exit(-1); &#125; list-&gt;pTail = list-&gt;pHead; list-&gt;pTail-&gt;next = NULL; int len; cout&lt;&lt;\"请输入你想生成链表的节点数！\"&lt;&lt;endl; cin&gt;&gt;len; for (int i = 1; i &lt;= len; ++i) &#123; PNODE pNew = (PNODE)malloc(sizeof(NODE)); cout&lt;&lt;\"请输入一个第\"&lt;&lt;i&lt;&lt;\"个节点的值！\"&lt;&lt;endl; int val; cin&gt;&gt;val; if (pNew == NULL)&#123; cout&lt;&lt;\"New node malloc failed!\"&lt;&lt;endl; &#125; pNew-&gt;data = val; list-&gt;pTail-&gt;next = pNew; pNew-&gt;next = NULL; list-&gt;pTail = pNew; &#125;&#125; 这里需要注意的是：一开始，将链表尾节点指针指向链表头节点之后，紧接着记得将尾节点（这时也等同于头节点）的next置为NULL。 头节点本身不存储数据，只是用来操作。那么，在用户输入链表节点数为0的时候，生成的链表就是空的。头节点的next为NULL就代表链表为空。 判断链表是否为空12345bool is_Empty(LIST list)&#123; if(NULL == list.pHead-&gt;next) return true; return false;&#125; 遍历链表123456void traverse_List(LIST list)&#123; PNODE p; for(p = list.pHead-&gt;next; p ; p = p-&gt;next)&#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; &#125;&#125; 这个for循环不可谓不经典！ 链表长度1234567int len_List(LIST list)&#123; int cnt = 0; for(PNODE p = list.pHead-&gt;next ; p ; p = p-&gt;next)&#123; cnt++; &#125; return cnt;&#125; 链表排序123456789101112void sort(PLIST pList)&#123; PNODE p,q; for (p = pList-&gt;pHead-&gt;next; p-&gt;next ;p = p-&gt;next)&#123; for(q = p-&gt;next ; q ; q = q-&gt;next)&#123; if(p-&gt;data &gt; q-&gt;data)&#123; int temp = q-&gt;data; q-&gt;data = p-&gt;data; p-&gt;data = temp; &#125; &#125; &#125;&#125; 冒泡排序嘛，第一层循环len-1次，第二层要比较到最后。 添加节点1234567891011121314151617181920void add(PLIST plist)&#123; int num; cout&lt;&lt;\"请输入想要添加节点个数！\"&lt;&lt;endl; cin&gt;&gt;num; for (int i = 1; i &lt;= num; ++i) &#123; int val; cout&lt;&lt; \"请输入添加的第\"&lt;&lt;i&lt;&lt;\"个节点！\"&lt;&lt;endl; cin&gt;&gt;val; PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL != pNew) &#123; pNew-&gt;data = val; pNew-&gt;next = NULL; plist-&gt;pTail-&gt;next = pNew; plist-&gt;pTail = pNew; &#125; else&#123; cout&lt;&lt;\"new node add failed!\"&lt;&lt;endl; exit(-1); &#125; &#125;&#125; 和初始化写法差不多 插入节点1234567891011121314151617181920212223242526272829bool insert(PLIST plist)&#123; int pos, val;//在第pos个节点的前一个位置插入val，pos从1开始 cout&lt;&lt;\"请输入需要插入的位置：\"&lt;&lt;endl; cin &gt;&gt;pos; cout&lt;&lt;\"请输入插入的元素：\"&lt;&lt;endl; cin&gt;&gt;val; int i = 0; PNODE p = plist-&gt;pHead; while (NULL != p &amp;&amp; i &lt; pos - 1)&#123; i++; p = p-&gt;next; &#125; if(i &gt; pos - 1 || p == NULL) return false; PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL == pNew) return false; PNODE q;//临时存放原来pos位置的节点 pNew-&gt;data = val; q = p-&gt;next; p-&gt;next = pNew; pNew-&gt;next = q; return true;&#125; 这个while循环找到插入位置很精髓有木有？ 加个if判断，我想主要是总共就5个节点，用户却想在第10个位置插入，那还叫插入嘛。。那是无中生有！ 删除节点123456789101112131415161718192021bool delete_List(PLIST plist)&#123; int pos;//删除第pos个位置的元素 cout&lt;&lt;\"请输入需要删除的元素的位置：\"&lt;&lt;endl; cin &gt;&gt;pos; //找到需要被删除节点的上一个节点位置，并用p指向它 int i = 0; PNODE p = plist-&gt;pHead; while (NULL != p-&gt;next &amp;&amp; i &lt; pos - 1)&#123; i++; p = p-&gt;next; &#125; if(i &gt; pos - 1 || NULL == p-&gt;next) return false; PNODE q = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; free(q); return true;&#125; 同样是用while找位置，但和上面的有点小小的不同。这里要找的位置，是需要删除节点的上一个节点。所以判断whil循环结束的条件有差别。 我写的时候还犯了个小错误。 就是最后删除的时候，不是定义了个临时指针q把需要删除的元素先存起来嘛。我紧接着就把q（也就是p的next）给free掉了，最后才将p的next指向p的next的next，可p的next（q）早就被我free掉了。然后死循环了。。。 单元测试123void test(LIST list)&#123;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://oceanmiki.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"http://oceanmiki.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"C","slug":"C","permalink":"http://oceanmiki.github.io/tags/C/"}]},{"title":"C++之链表中的指针","slug":"C++之链表里的指针","date":"2020-02-11T14:54:35.051Z","updated":"2020-02-12T11:41:13.729Z","comments":true,"path":"2020/02/11/C++之链表里的指针/","link":"","permalink":"http://oceanmiki.github.io/2020/02/11/C++%E4%B9%8B%E9%93%BE%E8%A1%A8%E9%87%8C%E7%9A%84%E6%8C%87%E9%92%88/","excerpt":"刚开始写链表的时候，指针用的不熟悉，都是一些简单的小毛病。（有机会继续补充，逃","text":"刚开始写链表的时候，指针用的不熟悉，都是一些简单的小毛病。（有机会继续补充，逃 语法一12345//在这里定义一个结构体typedef struct Node&#123; int val; struct Node *pNext;&#125;NODE, *PNODE; 比如说，我有次把一个结构体指针写成了： 1struct *Node pHead; IDE都报错了“Declaration of anonymous struct must be a definition”，我还回去检查结构体…汗。 正确写法： 1struct Node *pHead; *说明它后面跟着的变量是一个指针，指针指向的内容的类型是前面的struct Node，这样记忆就清晰很多了。 二当需要对结构体中的值进行操作的时候，如果用的是结构体的直接小数点点一下就好。 12struct Node p;p.val = 201314; 但如果用的是结构体指针的话，点是出不来东西的，用个“-&gt;”，形象点可以叫arrow。 1pHead-&gt;val = 201314; 为什么这都要说一下呢？这是因为，Clion非常智能地在我试图用结构体指针点东西的时候，自动改成arrow。我怕以后形成习惯了。。。 三在函数里面，静态内存在函数执行完毕之后就会消失，动态内存分配则还会存在。 123NODE *node = (NODE*)malloc(sizeof(NODE));//PNODE node = (PNODE)malloc(sizeof(NODE)); 等号右边的（NODE*）表示的是类型转换。 sizeof（）里面的是你要分配的空间大小，这里要分配的是一个结构体，而不是一个指针。 检查还比如说，链表的一些操作总容易忘记检查一些指针是否非空就开始操作，翁恺老师讲了一个很机械的方法，我感觉给我这种笨人检查挺好用的。 How do we find the boundary? Any pointer at the left of -&gt; must be checked.","categories":[{"name":"C++","slug":"C","permalink":"http://oceanmiki.github.io/categories/C/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://oceanmiki.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"http://oceanmiki.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"C++之指针的指针","slug":"C++之指针的指针","date":"2020-02-08T03:07:20.566Z","updated":"2020-02-08T03:36:48.611Z","comments":true,"path":"2020/02/08/C++之指针的指针/","link":"","permalink":"http://oceanmiki.github.io/2020/02/08/C++%E4%B9%8B%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88/","excerpt":"需要修改指针指向的时候，参数传入指针的指针。","text":"需要修改指针指向的时候，参数传入指针的指针。 比如使用链表时，你有一个头结点指针。 在某个函数中（比如说添加新的节点add函数）你需要对头结点指针进行修改，如果只是将头结点指针当成形式参数传进函数，函数里面的参数只是一个对头结点指针的副本，作用域只是在函数内部,在函数里面对它的任何操作不会影响函数外真正的头结点指针 。 1void add(Node *head,int num); 一种解决方法是将头结点指针定义为全局变量。但全局变量是有局限性的，会使得add函数变成一次性的函数。当你的程序中需要使用多个链表的时候呢？ 这时候,你看到了函数的返回值是void。噢，太棒了，你不是要修改头指针吗？诶，我把头指针修改之后返回！ 1Node* add(Node *head, int num); 但显然用起来变得麻烦了，每次调用add函数还得接收一下返回值。（万一忘了呢？） 1head = add(head, number); 还有一种办法就是传递头结点指针的指针，也就是把头结点指针的地址传入(C++中也可以理解为引用)，这样就可以在函数中直接操作原来的头结点指针了。 1void add(Node **head, int num); 当然,对于链表,这只是初级封装的办法,更好的封装性写法可以再定义一个链表结构体或者是用一个几乎在链表生命期内不会被修改的哨兵型头结点(双向链表的尾结点同理)。如果一定要用C写封装性良好的代码，时刻想着把C里面的结构体跟C++中的类作类比。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;struct Node&#123; int num; struct Node *next;&#125;;void add(Node *h,int n);void test(Node *h);int main()&#123; Node *head = NULL; head = (Node*)(malloc(sizeof(Node))); head-&gt;num = 5; test(head); cout&lt;&lt;\"test之后main里面的num:\"&lt;&lt;head-&gt;num&lt;&lt;endl&lt;&lt;\"地址：\"&lt;&lt;head&lt;&lt;endl; return 0;&#125;void test(Node *h)&#123; h-&gt;num = 10; cout&lt;&lt;\"test里面还没修改的地址：\"&lt;&lt;h&lt;&lt;endl; h = (Node*)(malloc(sizeof(Node))); cout&lt;&lt;\"test里面重新对h赋值后的地址：\"&lt;&lt;h&lt;&lt;endl;&#125;/* 输出： test里面还没修改的地址：0x181550 test里面重新对h赋值后的地址：0x181570 test之后main里面的num:10 地址：0x181550*/ 上面的这个例子能够很好的解释传入的结构体指针其实还是值传递。 我们可以看到，再main函数中，一开始就为head指针malloc一片内存，这时候里面的地址是：0x181550，然后为head里面的num赋值为5。 之后，调用test函数将h里面的num修改成10，然后此时输出的地址其实还是一开始malloc的值。 再之后，对h重新malloc新的内存，通过输出发现此时h的值改变了（变成了：0x181570）。 回到main函数，看到输出就明白了。刚才在test里面的修改，在main函数里面只能改变指针指向的内容num（把5变成了10）。 然而，指针的值是不会改变的。这是因为函数值传递的关系，通过函数形参穿过去的值都只是复制了一份。test（）函数执行完之后，并不会改变原来的值。 这其实和刚开始学C的时候想用自定义一个swap（int a, int b）函数的值传递是一样的。想要真正交换两个数的值要写成swap（int *a, int *b） 。 这里想要修改指针Node *head的值，就必须要用到指针的指针Node **head。","categories":[{"name":"C++","slug":"C","permalink":"http://oceanmiki.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://oceanmiki.github.io/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://oceanmiki.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"值传递","slug":"值传递","permalink":"http://oceanmiki.github.io/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"}]},{"title":"Java语言之时间LocalDateTime","slug":"Java语言之时间LocalDateTime","date":"2020-02-02T09:25:52.945Z","updated":"2020-02-02T12:38:03.238Z","comments":true,"path":"2020/02/02/Java语言之时间LocalDateTime/","link":"","permalink":"http://oceanmiki.github.io/2020/02/02/Java%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%B6%E9%97%B4LocalDateTime/","excerpt":"从 Java 8 开始，java.time包提供了新的日期和时间API，以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。和旧的API相比，新的对日期和时间进行运算更加方便。","text":"从 Java 8 开始，java.time包提供了新的日期和时间API，以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。和旧的API相比，新的对日期和时间进行运算更加方便。 最常用的LocalDateTime获取当前日期和时间1LocalDateTime now = LocalDateTime.now(); 通过指定的日期和时间创建1234567//使用of()方法LocalDateTime localDateTime = LocalDateTime.of(2019, 8, 27, 13, 14, 00);LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);LocalDateTime dt3 = LocalDateTime.of(d2, t2); 其中of（）方法是重载的，这里演示使用 年月日时分秒 ，也可以选择不使用秒数等的方法。 而且与Date不同，不需要考虑时间偏移的问题，月份一 一对应，星期也是1~7对对应星期一到星期日。 DateTimeFormatter的使用自定义格式时间和日期一般来说： 日期：yyyy-MM-dd 时间：HH:mm:ss 这里需要注意的是月份MM大写（为了和分钟区分），小时HH大写是为了使用24小时进制的时间。如果写成hh，当parse某个字符串中使用大于12的小时（13，14…）会抛异常。 格式化时间123456789LocalDateTime now = LocalDateTime.now();DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");String str = dateTimeFormatter.format(now);System.out.println(now);System.out.println(str);//输出： 2020-02-02T15:14:34.092 2020-02-02 15:14:34 使用ofPattern()方法自定义格式。 解析时间12345678910String str = new String(\"2019-08-27 13:14:00\");LocalDateTime localDateTime = LocalDateTime.parse(str,dateTimeFormatter);String format = dateTimeFormatter.format(localDateTime);System.out.println(format);//用上面的格式化方法得到字符串，和原来的一样System.out.println(localDateTime);//解析后的LocalDateTime//输出：2019-08-27 13:14:002019-08-27T13:14 这里严格按照ISO 8601的格式，注意ISO 8601规定的日期和时间分隔符是 T 。 这里我发现一个细节，就是当解析的时间秒数为00的时候，解析后的LocalDateTime会自动省略秒数。 对时间日期的加减运算简单的：plus就是加，minus就是减，还可以链式操作哦。 123456789101112public class Main &#123; public static void main(String[] args) &#123; LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt); // 加5天减3小时: LocalDateTime dt2 = dt.plusDays(5).minusHours(3); System.out.println(dt2); // 2019-10-31T17:30:59 // 减1月: LocalDateTime dt3 = dt2.minusMonths(1); System.out.println(dt3); // 2019-09-30T17:30:59 &#125;&#125; 注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。 对时间日期的设置你以为用set？no no no… 对日期和时间进行调整则使用withXxx()方法，例如：withHour(15)会把10:11:12变为15:11:12： 调整年：withYear() 调整月：withMonth() 调整日：withDayOfMonth() 调整时：withHour() 调整分：withMinute() 调整秒：withSecond() 123456789101112public class Main &#123; public static void main(String[] args) &#123; LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt); // 日期变为31日: LocalDateTime dt2 = dt.withDayOfMonth(31); System.out.println(dt2); // 2019-10-31T20:30:59 // 月份变为9: LocalDateTime dt3 = dt2.withMonth(9); System.out.println(dt3); // 2019-09-30T20:30:59 &#125;&#125; 同样注意到调整月份时，会相应地调整日期，即把2019-10-31的月份调整为9时，日期也自动变为30。 实际上，LocalDateTime还有一个通用的with()方法允许我们做更复杂的运算。例如： 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; // 本月第一天0:00时刻: LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay(); //或者 LocalDateTime firstDay = LocalDateTime.now().withDayOfMonth(1).withHour(00).withMinute(00).withSecond(00).withNano(000); System.out.println(firstDay); // 本月最后1天: LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth()); System.out.println(lastDay); // 下月第1天: LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(nextMonthFirstDay); // 本月第1个周一: LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); System.out.println(firstWeekday); //某个月的第一天 LocalDate localDate = LocalDate.parse(\"2019-02-02\",DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); LocalDate first = localDate.withDayOfMonth(1); System.out.println(first); //某个月的最后一个星期四（11月的就是感恩节） LocalDate localDate = LocalDate.parse(\"2020-11-02\",DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); LocalDate last = localDate.with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY)); System.out.println(last); &#125;&#125; 注意用到TemporalAdjusters末尾的s，不然就没有后面的静态方法。如果获取到某个月的最后一天的值返回给的不是LocalDate而是LocalDateTime，时间是不会自动变成23：59：59的，需要的自己设定。某个月的第一天也是这样。 其他Java 8引入了新的日期和时间API，它们是不变类，默认按ISO 8601标准格式化和解析； 使用LocalDateTime可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象； 使用isBefore()和isAfter()可以判断日期和时间的先后； 使用Duration和Period可以分别表示两个日期和时间的“区间间隔”。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://oceanmiki.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"时间","slug":"时间","permalink":"http://oceanmiki.github.io/tags/%E6%97%B6%E9%97%B4/"},{"name":"DateTimeFormatter","slug":"DateTimeFormatter","permalink":"http://oceanmiki.github.io/tags/DateTimeFormatter/"}]},{"title":"Java语言之线程安全","slug":"Java语言之线程安全","date":"2020-01-27T06:32:21.000Z","updated":"2020-02-02T12:35:33.097Z","comments":true,"path":"2020/01/27/Java语言之线程安全/","link":"","permalink":"http://oceanmiki.github.io/2020/01/27/Java%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","excerpt":"在多线程程序中，会出现多个线程抢占一个资源的情况，这时间有可能会造成冲突，也就是一个线程可能还没来得及将更改的资源保存，另一个线程的更改就开始了。","text":"在多线程程序中，会出现多个线程抢占一个资源的情况，这时间有可能会造成冲突，也就是一个线程可能还没来得及将更改的资源保存，另一个线程的更改就开始了。 问题提出现有100张电影票交给3个售票窗口出售。每一个窗口用一个线程表示。 使用继承Thread方式： 12345678910111213141516171819202122232425262728293031323334353637class Window2 extends Thread&#123; private static int ticket = 100; public Window2() &#123; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125;&#125;public class Tread &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.start(); t2.start(); t3.start(); &#125;&#125; 这样的代码存在线程安全问题，会出现不同窗口卖出同一张票（重票），或者卖出不存在的票（错票：如-1号票）。 使用同步代码块处理线程安全问题Runable接口示例：123456789101112131415161718192021222324252627282930313233343536class Window implements Runnable&#123; Object obj = new Object(); private int ticket = 100; @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Window window = new Window(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.start(); t2.start(); t3.start(); &#125;&#125; 说明：123synchronized(同步监视器)&#123; //需要同步的代码&#125; 同步监视器（俗称叫作锁）：任何一个类的对象都可以充当锁。要求：多个线程必须共用同一把锁，锁必须是唯一的。 在Runable接口中不必每次都new一个obj，可以直接使用this（即当前对象实例）充当锁。因为在main方法中只new了一个Window对象，所以当前对象实例是唯一的。 继承Thread类示例：1234567891011121314151617181920212223242526272829303132333435class Window2 extends Thread&#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; synchronized (Window2.class) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class Tread &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.start(); t2.start(); t3.start(); &#125;&#125; 注意这里，如果想要使用new一个obj对象： 1Object obj = new Object(); 线程还是不安全的，因为obj是非静态的属性，而在main方法中Window2对象new了3个，相当于每个线程都有一把自己的锁，那么此时锁就不唯一了。 那么可以将obj修改为静态的： 1static Object obj = new Object(); 或者像实例一样使用当前类Window2.class（这也是一个对象，而且是唯一的）。 使用同步方法解决线程安全问题Runable接口示例：1234567891011121314151617181920212223242526272829303132333435class Window implements Runnable&#123; private int ticket = 100; private synchronized void show() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125; &#125; @Override public void run() &#123; while (ticket &gt; 0) &#123; show(); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Window window = new Window(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.start(); t2.start(); t3.start(); &#125;&#125; 同步代码块是将需要同步处理的代码包起来，如果需要同步的数据恰好就在一个方法中，我们就可以把这个方法设置成同步方法，例如示例中的show（）方法。 同步方法仍然有同步监视器，只不过不需要我们显式的声明。 Runable接口示例里面的同步方法show（）中，它的同步监视器就是this。 继承Thread类示例：1234567891011121314151617181920212223242526272829303132class Window2 extends Thread&#123; private static int ticket = 100; private static synchronized void show()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125; &#125; @Override public void run() &#123; while (ticket &gt; 0) &#123; show(); &#125; &#125;&#125;public class Tread &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.start(); t2.start(); t3.start(); &#125;&#125; 同样地，这里的同步方法也必须为static，而由于静态方法不能调用非静态属性，票数（ticket）也必须为static的。 这里show（）方法的锁就是当前类对象Window2.class. 单例模式之懒汉模式的线程安全123456789101112131415161718192021222324252627282930class Lazy&#123; private Lazy() &#123; &#125; private static Lazy instance = null; public static Lazy getInstance() &#123; //效率低：// synchronized (Lazy.class)&#123;// if(instance == null)&#123;// instance = new Lazy();// &#125;// return instance;// &#125; //推荐: if (instance == null) &#123; synchronized (Lazy.class) &#123; if (instance == null) &#123; instance = new Lazy(); &#125; &#125; &#125; return instance; &#125;&#125;public class 单例模式之懒汉式 &#123; public static void main(String[] args) &#123; Lazy instance = Lazy.getInstance(); &#125;&#125; 一开始可能几个线程同时判断 instance == null，需要等待进入同步代码块，是单线程的。可是后来只要有instance被 new 出来了。更多的其他线程判断 instance != null 即可直接返回 instance 对象实例，无需再等待。 Lock锁解决线程安全问题1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;class Window implements Runnable&#123; private int ticket = 100; private ReentrantLock lock = new ReentrantLock(true); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" sells: \" + ticket); ticket--; &#125;else &#123; break; &#125; &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;public class Lock &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.start(); t2.start(); t3.start(); &#125;&#125; 首先new一个Lock接口的实现类ReetrantLock实例对象lock，然后手动 lock 需要同步的代码，最后手动 unlock。 而synchronized不同，它在代码块的最后就会自动解锁。 两者对比来说Lock更灵活，但容易忘记解锁。 线程的其他问题在运行代码的时候不难发现，线程安全是安全了，可是运行的效率也变慢了。这是因为原本多线程在同步的地方又变成了单线程了。还有可能遇到“死锁”问题。 线程通信涉及的方法 wait（）方法：一旦执行方法，当前线程进入阻塞状态，并且释放同步监视器； notify（）方法：按优先级唤醒一个线程； notifyAll（）：唤醒所有线程。 注意事项： 必须在同步代码块或方法里面调用wait() 与 notify/notifyAll()方法； 三个方法的调用者必须是同步代码块或同步方法中的同步监视器； 这三个方法定义在java.lang.Object类中。 sleep（）和 wait（）的异同相同：都可以使当前线程进入阻塞状态； 不同： 这两个方法来自不同的类分别是Thread和Object； 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法； wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）； sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常； sleep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://oceanmiki.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"线程安全","slug":"线程安全","permalink":"http://oceanmiki.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"同步监视器","slug":"同步监视器","permalink":"http://oceanmiki.github.io/tags/%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8/"}]},{"title":"经典算法之快速排序","slug":"经典算法之快速排序","date":"2020-01-23T07:01:44.000Z","updated":"2020-02-19T12:26:38.175Z","comments":true,"path":"2020/01/23/经典算法之快速排序/","link":"","permalink":"http://oceanmiki.github.io/2020/01/23/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"快速排序的排序效率在同为O(N*logN)的几种排序方法中效率较高，其中还运用了分治法的思想。","text":"快速排序的排序效率在同为O(N*logN)的几种排序方法中效率较高，其中还运用了分治法的思想。 基本思想 先从数列中取出一个数作为基准数。（随便选，一般可以选择第一个数） 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 具体步骤 0 1 2 3 4 5 6 7 8 9 72 6 57 88 60 42 83 73 48 85 首先，选择基准数 72（索引Index: 0 ）,算法开始的目标就是在上面这个序列中找到一个位置（假设对应的索引为 k ），把 72 放到这个位置之后，以 k 为分界点，左边的数都比 72 小，右边的数都比 72 大； 再定义两个索引 high 和 low ，high 指向序列最右端的 85 （即 high = 9），low 指向 序列除基准数外的最左端的 6 （即 low = 1）； 用这两个索引从序列两端开始“探测”，high 负责找到一个比基准数 72 小 的数，low 负责找到一个比基准数 72 大 的数。移动 high 和 low 的时候必须：先从后向前找，再从前向后找 （即先 high - - 再 low++）； 0 1 2 3 4 5 6 7 8 9 72 6 57 88 60 42 83 73 48 85 如上图所示，high 先移动到 48 （high = 8）处停下。low 再开始移动，移动到 88 （low = 3） 处停下 。high 代表它指的数要比基准数 高 ，low 代表它指的数要比基准数 低。因此当他们两个遇到不满足要求的数时需要停下来进行 交换 。（索引不动） 0 1 2 3 4 5 6 7 8 9 72 6 57 48 60 42 83 73 88 85 交换之后继续：先从后向前找，再从前向后找 。此时 high 停在了 42 处 low 还没找到比基准数大的数就与 high 相遇了。此时， high 和 low 的索引都为 5 ，“探测”结束。 0 1 2 3 4 5 6 7 8 9 72 6 57 48 60 42 83 73 88 85 现在把相遇位置的 42 与基准数 72 交换。 0 1 2 3 4 5 6 7 8 9 42 6 57 48 60 72 83 73 88 85 现在清楚为什么要让 high 先移动了。第一轮“探测”结束，可以看见基准数 72 （k = 5）两边（不一定对称）被划分成两个序列，左边序列的数字都比 72 小，右边序列的数字都比 72 大。 接下来用相同的方法处理这两个序列，72 左边序列处理完应该如下：（基准数： 42） 0 1 2 3 4 6 42 57 48 60 左边序列又被划分成两个序列，其中左边序列只有一个数字：6 ，说明已经处理完了，继续处理右边序列。处理完如下： 2 3 4 48 57 60 此时左右两个序列都处理完。 还有 72 右边的序列…都处理完如下图所示： 0 1 2 3 4 5 6 7 8 9 6 42 57 48 60 72 73 83 85 88 代码实现百度百科抄的 1234567891011121314151617181920212223242526272829303132 public static int[] qsort(int arr[],int start,int end) &#123; int pivot = arr[start]; int low = start; int high = end; while (low &lt; high) &#123; while ((low &lt; high)&amp;&amp;(arr[high]&gt;pivot)) &#123; high--; &#125; while ((low &lt; high)&amp;&amp;(arr[low]&lt;pivot)) &#123; low++; &#125; if ((arr[low]==arr[high])&amp;&amp;(low &lt; high)) &#123; low++; &#125; else &#123; int temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; &#125; &#125; if (low-1&gt;start) arr=qsort(arr,start,low-1); if (high+1&lt;end) arr=qsort(arr,high+1,end); return (arr); &#125; public static void main(String[] args) &#123; int arr[] = new int[]&#123;3,3,3,7,9,122344,4656,34,34,4656,5,6,7,8,9,343,57765,23,12321&#125;; int len = arr.length-1; arr=qsort(arr,0,len); for (int i:arr) &#123; System.out.print(i+\"\\t\"); &#125; &#125; # 补充 看了韩老师的视频，我感觉下面这个代码可读性好点，也容易想出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class QuickSort &#123; public static void main(String[] args) &#123; int arr[] = new int[]&#123;3,3,3,7,9,122344,4656,34,34,4656,5,6,7,8,9,343,57765,23,12321&#125;; int len = arr.length-1; qsort(arr,0,len); for (int i:arr) &#123; System.out.print(i+\"\\t\"); &#125; &#125; public static void qsort(int []arr, int left, int right)&#123; int l = left; int r = right; int pivot = arr[ (l + r) / 2];//选用中间值作为基准 //while循环使当前选定中值（基准）的左边都比它小，右边都比它大 while (l &lt; r)&#123; //在pivot的左边找一个比它大的 //如果没有找到，说明此时pivot的左边都比它小 //而且此时l == pivot对应的数组下标，后面要处理一下，避免死循环 while( arr[l] &lt; pivot )&#123; l++; &#125; //在pivot的右边找一个比它小的，同上 while( arr[r] &gt; pivot )&#123; r--; &#125; //这里就是前面说的处理，满足条件说明pivot左边都比它小，右边都比它大 //那就不用进行下面的操作了呗，直接跳出循环 //判读条件写==也行，你开心就好 if(l &gt;= r)&#123; break; &#125; //如果上面没有退出循环，这里接着就要交换一大一小的两个值 int temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完发现arr[l] == pivot，就将 r-- ,相当于前移 //因为这里有种情况要考虑，比如数组中有三个这样的数字： 0 0 0 //运行到 l 是左边的 0 ，r 是右边的0，pivot是中间的 //下一次循环时 l r pivot都不会改变，l == pivot == r //又开始交换，又进入下一次循环，又开始交换。。。死循环 if(arr[l] == pivot)&#123; r--; &#125; //同上 if(arr[r] == pivot)&#123; l++; &#125; &#125; //上面的循环保证了此时的pivot的左边都是比它小的，右边都是比它大的 //接下来可以开始准备递归，但是递归前还要加个判断 //看到break的条件，发现此时有可能 l == r //，如果相等就必须将l和r错开，否则，会报栈溢出的错误 //因为最后的最后，全部排好序了 // l = r 其实最后就是left = right //没有这个判读，直接不停地递归 //一下子就StackOverflowError if(l == r)&#123; l++; r--; &#125; //向左递归 //就是递归的意思。。。都不用想，边界肯定是这样的 //要想弄懂递归，首先要弄懂递归 //先向左向右都行，你开心就好 //如果注释掉向左递归，那么中值右边的就都是有序的，左边的就不一定了 if( left &lt; r)&#123; qsort(arr,left,r); &#125; //向右递归，同上 if ( right &gt; l)&#123; qsort(arr,l,right); &#125; &#125;&#125; ·","categories":[{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"快速排序","slug":"快速排序","permalink":"http://oceanmiki.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"Java数据结构之稀疏数组","slug":"Java数据结构之稀疏数组","date":"2020-01-23T04:47:05.000Z","updated":"2020-01-27T12:16:31.079Z","comments":true,"path":"2020/01/23/Java数据结构之稀疏数组/","link":"","permalink":"http://oceanmiki.github.io/2020/01/23/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/","excerpt":"稀疏数组可以看做是普通数组的压缩，但是这里说的普通数组是值无效数据量远大于有效数据量的数组。","text":"稀疏数组可以看做是普通数组的压缩，但是这里说的普通数组是值无效数据量远大于有效数据量的数组。 稀疏数组的应用编写一个五子棋程序的存档和读档： 黑 白 如图一个 11 x 11 的棋盘只下了两步棋子，如果用一个 11 x 11 的二维数组保存。 黑子的位置（【1,2】）存为1，白子的位置（【2，3】）存为2的话，耗费了大量的空间存空白位置。 为了节省空间，可以运用稀疏数组a[3] [3]: row col val 0 11 11 2 1 1 2 1 2 2 3 2 上面变成 3 x 3 的一个稀疏数组：第一行 a [0] ，存储棋盘共有 11 行，11 列，除空白位置（val = 0）外，有效值有两个。其余行（a [1] 和 a[2] ）记录每个有效位置的坐标与对应值。 稀疏数组与二维数组互相转化二维数组转稀疏数组 遍历原始二维数组，得到有效数据总数 sum ； 创建稀疏数组 sparseArr int [sum + 1] [3] ; 遍历原始二维数组，记录有效数据坐标. 稀疏数组转二维数组 读取稀疏数组第一行，创建二维数组； 读取余下的数据记录，将对应坐标的值赋给二维数组. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package 稀疏数组SparseArray;import java.util.Iterator;public class SparseArr &#123; public static void main(String[] args) &#123; // 创建一个 11*11 二维数组 int chessArr[][] = new int[11][11]; chessArr[1][2] = 1; chessArr[2][3] = 2; // 输出棋盘 System.out.println(\"原始二维数组：\"); for (int row[] : chessArr) &#123; for (int data : row) &#123; System.out.print(data); &#125; System.out.println(); &#125; // 得到有效数据总数 int sum = 0; for (int i = 0; i &lt; chessArr.length; i++) &#123; for (int j = 0; j &lt; chessArr.length; j++) &#123; if (chessArr[i][j] != 0) sum++; &#125; &#125; // 创建对应稀疏数组 int sparseArr[][] = new int[sum + 1][3]; sparseArr[0][0] = chessArr.length; sparseArr[0][1] = chessArr.length; sparseArr[0][2] = sum; // 给稀疏数组赋值 int count = 0; for (int i = 0; i &lt; chessArr.length; i++) &#123; for (int j = 0; j &lt; chessArr.length; j++) &#123; if (chessArr[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr[i][j]; &#125; &#125; &#125; // 输出稀疏数组的样式 System.out.println(); System.out.println(\"得到的稀疏数组如下：\"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); //稀疏数组转化二维数组 int chessArr2[][] = new int [sparseArr[0][0]][sparseArr[0][1]]; for (int i = 1; i &lt; sparseArr.length; i++) &#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //恢复后的二维数组 System.out.println(\"恢复后的二维数组:\"); for (int row[] : chessArr2) &#123; for(int data : row)&#123; System.out.print(data); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"稀疏数组","slug":"稀疏数组","permalink":"http://oceanmiki.github.io/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"}]},{"title":"爱情公寓5之张伟拔刀吧！","slug":"爱情公寓5之张伟拔刀吧！","date":"2020-01-21T10:59:23.000Z","updated":"2020-01-26T13:18:21.678Z","comments":true,"path":"2020/01/21/爱情公寓5之张伟拔刀吧！/","link":"","permalink":"http://oceanmiki.github.io/2020/01/21/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%935%E4%B9%8B%E5%BC%A0%E4%BC%9F%E6%8B%94%E5%88%80%E5%90%A7%EF%BC%81/","excerpt":"人生不就图个成果么？","text":"人生不就图个成果么？ 那个女孩有人说：一见钟情不过是见色起意。 爱5第一集，我用1.25倍速看剧情，1.5倍速看歌舞，0.5倍速看诸葛大力！第一眼看到诸葛大力，我就想起了陶喆/卢广仲唱的一首歌： 《那个女孩》 她有 最真的笑容 最美的想法 我一百分的女孩 那个女孩 留着长长的头发 穿着白色的衬衫 很专心听我说话 她的身上（有着淡淡的玫瑰花香） 总是那样（认真分析着我的笑话） 彷佛有种（谁也不应该宠坏她的）倔强 那个女孩说男生不要太帅 但脾气不能太坏 会唱歌的男生最让她崇拜 开口笑就会停不下来 每本书只会读到一半 在我的思维定势中，梦中情人一直有一个统一标准：24岁清纯漂亮的女大学生。 一道曼妙的身影袅袅而来，她黑发如墨，发丝如瀑，那张脸儿眉如远山，双眸如星辰，吹弹可破的脸颊桃腮白瓷，盈润娇艳的唇瓣鲜艳欲滴。 她身穿一件纯白如雪的修身宫装，如天鹅般优雅的脖颈处锁骨精美，骨瘦性感，那脖颈下胸膛处微微敞露出来的肌肤如同胭脂般的雪儿光滑，晶莹剔透，肤如凝脂。 而她的胸前，一对双峰最是饱满高耸，将薄薄的纱衣撑起，怒挺而出，虽不见一丝风采，却喷薄出令人遐想的光彩，那两座如同雪山的胸乳在纱衣笼罩之中，若隐若现，世间少有。 她的一双美腿修长，碧玉无瑕，高挑而又丰腴滚圆，莲步款款，每一步走动之间除了那摇曳的臀浪之外，还有那两条美腿在纱裙之中不断的晃荡，比那纯白纱裙还要白。 ​ ——《仙子下地狱》 看到诸葛大力后，我决定打破思维定势！然而，我却没想到我被更大的思维定势绊倒了。 就在我决定与大力私定终身之后，我发了条弹幕：诸葛大力❤冷亚麻色的？ 我满心欢喜打开弹幕列表，准备接受大家的祝福。满屏都是“awsl”、“大力我可以”。 就像歌曲里面唱的那样：没想到我们会喜欢同一种女孩！ 那个女孩，留着短短的头发 穿着美团的服装 得妻如此，夫复何求？ 夺妻之恨，不共戴天！那个男人。 张大炮、斯内克、张益达！一个复活地点在卫生间的金甲战士！ 伟大CP在第十四集的时候分手，十五集就复合了？wtf！现在流行把狗骗进来杀吗？ 真是人在家中坐，粮从天上来！ 我以为我是弹幕之神，一边调着倍速，一边用鼠标拽着进度条往前拉。 可是，无论我把 MC.Black 的饶舌回放多少遍，终究还是到了大力喊停的那一幕。她嘟起嘴巴勾起略微弯上的弧度提醒着我，暂停键该松开了。 人生不是演戏，不是说我把视频给暂停了，大力就还是我的。 我打电话给小黑，他给我讲了一个故事： 有个小伙喜欢女神很久了但是女神一直对他爱搭不理。 于是他去找了大师，他问道：大师我喜欢一个女孩子，但她不喜欢我也不拒绝我。每当我要放弃的时候她都会给我一口糖吃，大师我现在到底要怎么办啊？ 这时候，大师拿起了一个杯子接满了开水给小伙子，小伙子接过去，一下烫的把杯子摔碎在了地上。 大师道：烫吧？烫的时候放手就对了。 其实，这个世界没有什么是放不下的。痛了，你自然就放下了。 那个女孩，终究还是要回归到别人的怀抱… 为了不放下心爱的大力，我又找到了故事的后续： 小伙子若有所思说道：大师我能换个杯子吗？ 大师点了点头。 这时候小伙子从自己背包又拿出一个杯子，接满了开水，但这次他烫的手都快熟了也没有放手。 大师惊叹不已问道：不烫手么？ 小伙答：烫。 大师又问：何故不放手？ 小伙答：这水杯是她送的。 大师转过头幽幽叹道：舔狗真的牛批。 如果不是真的喜欢，谁又愿意当舔狗呢？ 想到这里，我更加坚定了自己的内心，正式决定加入 抢夺大力联盟 ！ 长夜将至，大力将失，我从今开始守望，至死方休。 我将不夜夜笙歌、不醉生梦死、不玩物丧志。 我将不戴宝冠，不争荣宠。 我将尽忠职守，生死於斯。 我是黑暗中的利剑，长城上的守卫。 我是抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。 我将生命与荣耀献给 抢夺大力联盟 今夜如此，夜夜皆然。","categories":[{"name":"电视剧","slug":"电视剧","permalink":"http://oceanmiki.github.io/categories/%E7%94%B5%E8%A7%86%E5%89%A7/"}],"tags":[{"name":"爱情公寓","slug":"爱情公寓","permalink":"http://oceanmiki.github.io/tags/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93/"},{"name":"诸葛大力","slug":"诸葛大力","permalink":"http://oceanmiki.github.io/tags/%E8%AF%B8%E8%91%9B%E5%A4%A7%E5%8A%9B/"}]}],"categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://oceanmiki.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"工作","slug":"工作","permalink":"http://oceanmiki.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"deploy","slug":"deploy","permalink":"http://oceanmiki.github.io/categories/deploy/"},{"name":"面试","slug":"面试","permalink":"http://oceanmiki.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/categories/Java/"},{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://oceanmiki.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://oceanmiki.github.io/categories/C/"},{"name":"Java基础","slug":"Java基础","permalink":"http://oceanmiki.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"电视剧","slug":"电视剧","permalink":"http://oceanmiki.github.io/categories/%E7%94%B5%E8%A7%86%E5%89%A7/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://oceanmiki.github.io/tags/Mac/"},{"name":"总结","slug":"总结","permalink":"http://oceanmiki.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"test","slug":"test","permalink":"http://oceanmiki.github.io/tags/test/"},{"name":"算法","slug":"算法","permalink":"http://oceanmiki.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"http://oceanmiki.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计网","slug":"计网","permalink":"http://oceanmiki.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://oceanmiki.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"String","slug":"String","permalink":"http://oceanmiki.github.io/tags/String/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://oceanmiki.github.io/tags/JavaWeb/"},{"name":"HTML","slug":"HTML","permalink":"http://oceanmiki.github.io/tags/HTML/"},{"name":"Java","slug":"Java","permalink":"http://oceanmiki.github.io/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://oceanmiki.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://oceanmiki.github.io/tags/LeetCode/"},{"name":"环形链表","slug":"环形链表","permalink":"http://oceanmiki.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"name":"力扣","slug":"力扣","permalink":"http://oceanmiki.github.io/tags/%E5%8A%9B%E6%89%A3/"},{"name":"单向链表","slug":"单向链表","permalink":"http://oceanmiki.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"环形队列","slug":"环形队列","permalink":"http://oceanmiki.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"},{"name":"指针","slug":"指针","permalink":"http://oceanmiki.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"C","slug":"C","permalink":"http://oceanmiki.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://oceanmiki.github.io/tags/C/"},{"name":"值传递","slug":"值传递","permalink":"http://oceanmiki.github.io/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"},{"name":"时间","slug":"时间","permalink":"http://oceanmiki.github.io/tags/%E6%97%B6%E9%97%B4/"},{"name":"DateTimeFormatter","slug":"DateTimeFormatter","permalink":"http://oceanmiki.github.io/tags/DateTimeFormatter/"},{"name":"线程安全","slug":"线程安全","permalink":"http://oceanmiki.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"同步监视器","slug":"同步监视器","permalink":"http://oceanmiki.github.io/tags/%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8/"},{"name":"快速排序","slug":"快速排序","permalink":"http://oceanmiki.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"http://oceanmiki.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"稀疏数组","slug":"稀疏数组","permalink":"http://oceanmiki.github.io/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"name":"爱情公寓","slug":"爱情公寓","permalink":"http://oceanmiki.github.io/tags/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93/"},{"name":"诸葛大力","slug":"诸葛大力","permalink":"http://oceanmiki.github.io/tags/%E8%AF%B8%E8%91%9B%E5%A4%A7%E5%8A%9B/"}]}